{"ast":null,"code":"import { PAGE_SIZE } from \"../config/config\";\n/**\n * A method that gets the all possible categories used in the\n * application data (without duplicated categories).\n *\n * @param {IApp[]} appsData - applications data.\n * @returns {string[]}\n */\n\nconst getCategories = appsData => {\n  const categoryList = new Set();\n  appsData === null || appsData === void 0 ? void 0 : appsData.forEach(({\n    categories\n  }) => {\n    categories === null || categories === void 0 ? void 0 : categories.forEach(categoryList.add, categoryList);\n  });\n  return Array.from(categoryList).sort();\n};\n/**\n * A method that gets the all apps that belong to a certain category.\n * Note: one app can belong to more than one category.\n *\n * @param {IApp[]} appsData - applications data.\n * @returns {IApp[]}\n */\n\n\nconst filterAppsByCategory = (appsData, category) => {\n  return appsData === null || appsData === void 0 ? void 0 : appsData.filter(({\n    categories\n  }) => {\n    return categories === null || categories === void 0 ? void 0 : categories.includes(category);\n  });\n};\n/**\n * A method that sorts the apps by ascending order of the\n * sum of the plans price.\n *\n * @param {IApp} a\n * @param {IApp} b\n * @returns {-1 | 0 | 1}\n */\n\n\nconst compareBySumOfPlansPrice = (a, b) => {\n  const getTotal = (elements, property) => {\n    return elements === null || elements === void 0 ? void 0 : elements.reduce((prev, cur) => {\n      return prev + cur[property];\n    }, 0);\n  };\n\n  const totalA = getTotal(a.subscriptions, \"price\");\n  const totalB = getTotal(b.subscriptions, \"price\");\n\n  if (totalA < totalB) {\n    return -1;\n  }\n\n  if (totalA > totalB) {\n    return 1;\n  }\n\n  return 0;\n};\n/**\n * A method that gets the minimum page number to paginate\n * the apps with page size = PAGE_SIZE\n *\n * @param {IApp[]} displayedApps\n * @returns {number}\n */\n\n\nconst getPagesNumber = displayedApps => {\n  return Math.ceil((displayedApps === null || displayedApps === void 0 ? void 0 : displayedApps.length) / PAGE_SIZE);\n};\n/**\n * A method that gets the apps that belong to a certain page number\n * due to the apps pagination.\n *\n * @param {IApp[]} displayedApps\n * @returns {number}\n */\n\n\nconst paginate = (apps, pageSize, pageNumber) => {\n  return apps.slice((pageNumber - 1) * pageSize, pageNumber * pageSize);\n};\n\nexport { getCategories, filterAppsByCategory, compareBySumOfPlansPrice, getPagesNumber, paginate };","map":{"version":3,"sources":["/Users/rafaelfecha/app-list-mini-challenge/src/utils/utils.ts"],"names":["PAGE_SIZE","getCategories","appsData","categoryList","Set","forEach","categories","add","Array","from","sort","filterAppsByCategory","category","filter","includes","compareBySumOfPlansPrice","a","b","getTotal","elements","property","reduce","prev","cur","totalA","subscriptions","totalB","getPagesNumber","displayedApps","Math","ceil","length","paginate","apps","pageSize","pageNumber","slice"],"mappings":"AACA,SAASA,SAAT,QAA0B,kBAA1B;AAEA;;;;;;;;AAOA,MAAMC,aAAa,GAAIC,QAAD,IAAgC;AACpD,QAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;AACAF,EAAAA,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAEG,OAAV,CAAkB,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAoB;AACpCA,IAAAA,UAAU,SAAV,IAAAA,UAAU,WAAV,YAAAA,UAAU,CAAED,OAAZ,CAAoBF,YAAY,CAACI,GAAjC,EAAsCJ,YAAtC;AACD,GAFD;AAGA,SAAOK,KAAK,CAACC,IAAN,CAAWN,YAAX,EAAyBO,IAAzB,EAAP;AACD,CAND;AAQA;;;;;;;;;AAOA,MAAMC,oBAAoB,GAAG,CAACT,QAAD,EAAmBU,QAAnB,KAAgD;AAC3E,SAAOV,QAAP,aAAOA,QAAP,uBAAOA,QAAQ,CAAEW,MAAV,CAAiB,CAAC;AAAEP,IAAAA;AAAF,GAAD,KAAoB;AAC1C,WAAOA,UAAP,aAAOA,UAAP,uBAAOA,UAAU,CAAEQ,QAAZ,CAAqBF,QAArB,CAAP;AACD,GAFM,CAAP;AAGD,CAJD;AAMA;;;;;;;;;;AAQA,MAAMG,wBAAwB,GAAG,CAACC,CAAD,EAAUC,CAAV,KAAsB;AACrD,QAAMC,QAAQ,GAAG,CAACC,QAAD,EAA4BC,QAA5B,KAAkD;AACjE,WAAOD,QAAP,aAAOA,QAAP,uBAAOA,QAAQ,CAAEE,MAAV,CAAiB,CAACC,IAAD,EAAOC,GAAP,KAAe;AACrC,aAAOD,IAAI,GAAGC,GAAG,CAACH,QAAD,CAAjB;AACD,KAFM,EAEJ,CAFI,CAAP;AAGD,GAJD;;AAMA,QAAMI,MAAM,GAAGN,QAAQ,CAACF,CAAC,CAACS,aAAH,EAAkB,OAAlB,CAAvB;AACA,QAAMC,MAAM,GAAGR,QAAQ,CAACD,CAAC,CAACQ,aAAH,EAAkB,OAAlB,CAAvB;;AACA,MAAID,MAAM,GAAGE,MAAb,EAAqB;AACnB,WAAO,CAAC,CAAR;AACD;;AACD,MAAIF,MAAM,GAAGE,MAAb,EAAqB;AACnB,WAAO,CAAP;AACD;;AACD,SAAO,CAAP;AACD,CAhBD;AAkBA;;;;;;;;;AAOA,MAAMC,cAAc,GAAIC,aAAD,IAAmC;AACxD,SAAOC,IAAI,CAACC,IAAL,CAAU,CAAAF,aAAa,SAAb,IAAAA,aAAa,WAAb,YAAAA,aAAa,CAAEG,MAAf,IAAwB/B,SAAlC,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOA,MAAMgC,QAAQ,GAAG,CAACC,IAAD,EAAeC,QAAf,EAAiCC,UAAjC,KAAwD;AACvE,SAAOF,IAAI,CAACG,KAAL,CAAW,CAACD,UAAU,GAAG,CAAd,IAAmBD,QAA9B,EAAwCC,UAAU,GAAGD,QAArD,CAAP;AACD,CAFD;;AAIA,SACEjC,aADF,EAEEU,oBAFF,EAGEI,wBAHF,EAIEY,cAJF,EAKEK,QALF","sourcesContent":["import { IApp, ISubscription } from \"../interfaces/app.interfaces\";\nimport { PAGE_SIZE } from \"../config/config\";\n\n/**\n * A method that gets the all possible categories used in the\n * application data (without duplicated categories).\n *\n * @param {IApp[]} appsData - applications data.\n * @returns {string[]}\n */\nconst getCategories = (appsData: IApp[]): string[] => {\n  const categoryList = new Set<string>();\n  appsData?.forEach(({ categories }) => {\n    categories?.forEach(categoryList.add, categoryList);\n  });\n  return Array.from(categoryList).sort();\n};\n\n/**\n * A method that gets the all apps that belong to a certain category.\n * Note: one app can belong to more than one category.\n *\n * @param {IApp[]} appsData - applications data.\n * @returns {IApp[]}\n */\nconst filterAppsByCategory = (appsData: IApp[], category: string): IApp[] => {\n  return appsData?.filter(({ categories }) => {\n    return categories?.includes(category);\n  });\n};\n\n/**\n * A method that sorts the apps by ascending order of the\n * sum of the plans price.\n *\n * @param {IApp} a\n * @param {IApp} b\n * @returns {-1 | 0 | 1}\n */\nconst compareBySumOfPlansPrice = (a: IApp, b: IApp) => {\n  const getTotal = (elements: ISubscription[], property: \"price\") => {\n    return elements?.reduce((prev, cur) => {\n      return prev + cur[property];\n    }, 0);\n  };\n\n  const totalA = getTotal(a.subscriptions, \"price\");\n  const totalB = getTotal(b.subscriptions, \"price\");\n  if (totalA < totalB) {\n    return -1;\n  }\n  if (totalA > totalB) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * A method that gets the minimum page number to paginate\n * the apps with page size = PAGE_SIZE\n *\n * @param {IApp[]} displayedApps\n * @returns {number}\n */\nconst getPagesNumber = (displayedApps: IApp[]): number => {\n  return Math.ceil(displayedApps?.length / PAGE_SIZE);\n};\n\n/**\n * A method that gets the apps that belong to a certain page number\n * due to the apps pagination.\n *\n * @param {IApp[]} displayedApps\n * @returns {number}\n */\nconst paginate = (apps: IApp[], pageSize: number, pageNumber: number) => {\n  return apps.slice((pageNumber - 1) * pageSize, pageNumber * pageSize);\n};\n\nexport {\n  getCategories,\n  filterAppsByCategory,\n  compareBySumOfPlansPrice,\n  getPagesNumber,\n  paginate,\n};\n"]},"metadata":{},"sourceType":"module"}